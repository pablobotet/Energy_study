# -*- coding: utf-8 -*-
"""Energy_study

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FpVtd6xZpsybQ0j5xORRwQ6kSNaIH-EL
"""

#Table1: Germany's daily data.
import requests
import pandas as pd
import json
from datetime import datetime, UTC

year_list= [i+2010 for i in range(15)]

for year in year_list:
    url=f'https://api.energy-charts.info/public_power?country=de&start={year}-01-01&end={year}-12-31'
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        timestamps = [datetime.fromtimestamp(ts, UTC).strftime('%Y-%m-%d %H:%M:%S') for ts in data['unix_seconds']]
        df = pd.DataFrame({'Timestamp': timestamps})
        for production in data['production_types']:
            df[production['name']] = production['data']
        try:
            df.to_csv(f'Energy_production_data_{year}.csv',index=False)
            print(f"File Energy_production_data_{year} saved succesfully")
        except:
            print(f"File Energy_production_data_{year} failed to save")


url=f'https://api.energy-charts.info/public_power?country=de&start=2010-01-01&end=2024-12-31'
response = requests.get(url)
if response.status_code == 200:
    data = response.json()
    timestamps = [datetime.fromtimestamp(ts, UTC).strftime('%Y-%m-%d %H:%M:%S') for ts in data['unix_seconds']]
    df = pd.DataFrame({'Timestamp': timestamps})
    for production in data['production_types']:
        df[production['name']] = production['data']
    try:
        df.to_csv(f'Energy_production_data_global.csv',index=False)
        print(f"Energy_production_data_global.csv saved succesfully")
    except:
        print(f"Energy_production_data_global.csv failed to save")

#Table 2. Germany's total capacity yearly data.
url='https://api.energy-charts.info/installed_power?country=de&time_step=yearly&installation_decommission=false'
response= requests.get(url)
if response.status_code==200:
    print(f'Succesful connection: {url}')
    data=response.json()
    df = pd.DataFrame({'year': data['time']})
    for production in data['production_types']:
        df[production['name']]=production['data']
    try:
        df.to_csv('Energy_capacity_yearly.csv',index=False)
        print('Energy_capacity_yearly.csv saves succesfully')
    except:
        print('Energy_capacity_yearly.csv failed to save')
    try:
        df.to_parquet('Energy_capacity_yearly.parquet',index=False)
        print('Energy_capacity_yearly.parquet saves succesfully')
    except:
        print('Energy_capacity_yearly.parquet saves succesfully')

#We now combine both tables to obtain total information on the yearly data.
import matplotlib.pyplot as plt
import numpy as np
energy_list=['Fossil gas','Nuclear', 'Biomass', 'Fossil brown coal / lignite','Fossil hard coal','Fossil oil','Solar','Wind onshore','Wind offshore','Biomass']

df=pd.read_csv('Energy_production_data_global.csv')
for column_name in df.columns:
    df[column_name]=df[column_name].fillna(0)

df['Timestamp'] = pd.to_datetime(df['Timestamp'])
df['year']=df['Timestamp'].dt.year
df=df.groupby('year').mean().reset_index()

df_2=pd.read_csv('Energy_capacity_yearly.csv')
df_new=df.merge(df_2,on='year',suffixes=('_generation_avg','_yearly_installation_capacity'))
df_new=df_new.fillna(0)
df_new=df_new.drop(columns=['Timestamp'])
for name in energy_list:
    df_new[name+'_capacity']=df_new[name+'_generation_avg']/(df_new[name+'_yearly_installation_capacity'].replace(0,np.nan)*1000)
df_new=df_new.fillna(0)
try:
    df_new.to_csv('Avg_yearly_data.csv',index=False)
    print(f"Avg_yearly_data.csv saved succesfully")
except:
    print(f"Avg_yearly_data.csv failed to save")

import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.holtwinters import ExponentialSmoothing

#We are now going to create objects to handle both Country and Company's data and develop a predicion model.
energy_list = ['Fossil gas','Nuclear', 'Biomass', 'Fossil brown coal / lignite','Fossil hard coal','Fossil oil','Solar','Wind onshore','Wind offshore','Biomass']

class Country:
    energy_list = ['Fossil gas','Nuclear', 'Biomass', 'Fossil brown coal / lignite','Fossil hard coal','Fossil oil','Solar','Wind onshore','Wind offshore','Biomass']

    co2_dictionary = {
        "Fossil gas": 469,
        "Nuclear": 16,
        "Biomass": 230,
        "Fossil brown coal / lignite": 1000,
        "Fossil hard coal": 900,
        "Fossil oil": 893,
        "Solar": 46,
        "Wind onshore": 12,
        "Wind offshore": 12
    }

    def __init__(self, name: str, df: pd.DataFrame = None):
        """
        Initializes Country with name and optional DataFrame.
        df: pd.DataFrame, optional
        """
        self.name = name
        self.installation = dict()
        self.energy_capacity = dict()
        self.pollution_data = Country.co2_dictionary
        if df is not None:
            expected_columns = {f"{energy}_yearly_installation_capacity" for energy in Country.energy_list} | \
                               {f"{energy}_capacity" for energy in Country.energy_list}
            missing_columns = expected_columns - set(df.columns)
            if missing_columns:
                raise ValueError(f"Missing columns in DataFrame: {missing_columns}")
            for index, row in df.iterrows():
                year = int(row["year"])
                self.installation[year] = dict()
                self.energy_capacity[year] = dict()
                for energy_type in Country.energy_list:
                    self.installation[year][energy_type] = row[energy_type + '_yearly_installation_capacity']
                    self.energy_capacity[year][energy_type] = row[energy_type + '_capacity']

    def update_capacity_key(self, year: int, energy_name: str, new_capacity: float):
        """
        Updates energy capacity for a given year and energy type.
        year: int, energy_name: str, new_capacity: float
        """
        if not year in self.energy_capacity:
            raise ValueError(f"{year} is not a possible key")
        if not energy_name in self.energy_capacity[year]:
            raise ValueError(f"{year} is not a possible key")
        self.energy_capacity[year][energy_name] = new_capacity

    def update_installation_key(self, year: int, energy_name: str, new_installation: float):
        """
        Updates installation capacity for a given year and energy type.
        year: int, energy_name: str, new_installation: float
        """
        if not year in self.installation:
            raise ValueError(f"{year} is not a possible key")
        if not energy_name in self.installation[year]:
            raise ValueError(f"{year} is not a possible key")
        self.energy_capacity[year][energy_name] = new_installation

    def calculate_co2_emission(self) -> dict:
        """
        Calculates total CO2 emissions per year.
        Returns: dict
        """
        co2_estimate = dict()
        for year in self.energy_capacity.keys():
            current_co2 = int(0)
            for energy_name in Country.energy_list:
                current_co2 += self.energy_capacity[year][energy_name] * Country.co2_dictionary[energy_name] * self.installation[year][energy_name] * 8760 * 1000000
            co2_estimate[year] = current_co2
        return co2_estimate

    def calculate_co2_intensity(self) -> dict:
        """
        Calculates CO2 intensity (gCO2/kWh) per year.
        Returns: dict
        """
        co2_intensity = dict()
        for year in self.energy_capacity.keys():
            total_yearly_production = float(0)
            yearly_intensity = float(0)
            for energy_name in Country.energy_list:
                total_yearly_production += self.energy_capacity[year][energy_name] * self.installation[year][energy_name]
            for energy_name in Country.energy_list:
                yearly_intensity += self.installation[year][energy_name] * self.energy_capacity[year][energy_name] / total_yearly_production * Country.co2_dictionary[energy_name]
            co2_intensity[year] = yearly_intensity
        return co2_intensity

    def predict_capacity(self, predict_num: int = 1, how: str = 'mean') -> None:
        """
        Predicts future capacity values.
        predict_num: int, how: str
        """
        next_year = int(max(self.energy_capacity.keys())) + 1
        for _ in range(predict_num):
            prediction_dictionary = {}
            for energy_name in Country.energy_list:
                past_years = list(self.energy_capacity.keys())
                past_values = [self.energy_capacity[year][energy_name] for year in past_years if energy_name in self.energy_capacity[year]]
                if how == 'mean':
                    prediction = np.mean(past_values) if past_values else 0
                elif how == 'linear_regression' and len(past_values) > 1:
                    X = np.array(past_years).reshape(-1, 1)
                    y = np.array(past_values)
                    model = LinearRegression().fit(X, y)
                    prediction = model.predict([[next_year]])[0]
                elif how == 'holt_winters' and len(past_values) > 1:
                    model = ExponentialSmoothing(past_values, trend='add', seasonal=None).fit()
                    prediction = model.forecast(1)[0]
                else:
                    prediction = past_values[-1] if past_values else 0
                prediction_dictionary[energy_name] = prediction
            self.energy_capacity[next_year] = prediction_dictionary
            next_year += 1

    def predict_installation(self, predict_num: int = 1, how: str = 'mean') -> None:
        """
        Predicts future installation values.
        predict_num: int, how: str
        """
        next_year = int(max(self.installation.keys())) + 1
        for _ in range(predict_num):
            prediction_dictionary = {}
            for energy_name in Country.energy_list:
                past_years = list(self.installation.keys())
                past_values = [self.installation[year][energy_name] for year in past_years if energy_name in self.installation[year]]
                if how == 'mean':
                    prediction = np.mean(past_values) if past_values else 0
                elif how == 'linear_regression' and len(past_values) > 1:
                    X = np.array(past_years).reshape(-1, 1)
                    y = np.array(past_values)
                    model = LinearRegression().fit(X, y)
                    prediction = model.predict([[next_year]])[0]
                elif how == 'holt_winters' and len(past_values) > 1:
                    model = ExponentialSmoothing(past_values, trend='add', seasonal=None).fit()
                    prediction = model.forecast(1)[0]
                else:
                    prediction = past_values[-1] if past_values else 0
                prediction_dictionary[energy_name] = prediction
            self.installation[next_year] = prediction_dictionary
            next_year += 1

class Company:
    energy_list = ['Fossil gas','Nuclear', 'Biomass', 'Fossil brown coal / lignite','Fossil hard coal','Fossil oil','Solar','Wind onshore','Wind offshore','Biomass']

    def __init__(self, name: str, country: Country, energy_capacity: dict = None):
        """
        Initializes Company with name, Country, and energy capacity.
        name: str, country: Country, energy_capacity: dict, optional
        """
        self.name = name
        self.country = country
        self.energy_capacity = energy_capacity if energy_capacity else dict()

    def calculate_co2_emissions(self, df_co2=None, dictionary_co2=None, df_capacity=None, dictionary_capacity=None) -> dict:
        """
        Calculates CO2 emissions of the company per year.
        Returns: dict
        """
        co2_estimate = dict()
        for year in self.country.energy_capacity.keys():
            for energy_type in Company.energy_list:
                co2_estimate[year] = co2_estimate.get(year, 0) + (
                    self.energy_capacity.get(energy_type, 0) *
                    Country.co2_dictionary.get(energy_type, 0) *
                    self.country.energy_capacity.get(year, {}).get(energy_type, 0)
                )
        return co2_estimate

    def calculate_co2_intensity(self) -> dict:
        """
        Calculates CO2 intensity of the company per year.
        Returns: dict
        """
        co2_intensity = dict()
        for year in self.country.energy_capacity.keys():
            total_yearly_production = float(0)
            yearly_intensity = float(0)
            for energy_name in Company.energy_list:
                total_yearly_production += self.country.energy_capacity.get(year, {}).get(energy_name, 0) * self.energy_capacity[energy_name]
            for energy_name in Company.energy_list:
                yearly_intensity += self.energy_capacity.get(energy_name, 0) * self.country.energy_capacity.get(year, {}).get(energy_name, 0) / total_yearly_production * Country.co2_dictionary[energy_name]
            co2_intensity[year] = yearly_intensity
        return co2_intensity

power_co_energy={
    'Solar':10,
    'Wind offshore':50,
    'Fossil gas':140
}
for name in energy_list:
    if name not in ['Solar','Wind offshore','Fossil gas']:
        power_co_energy[name]=0

germany=Country(name='Germany', df=pd.read_csv('Avg_yearly_data.csv'))
powerco=Company(name='Powerco',country=germany, energy_capacity=power_co_energy)

germany.predict_capacity(predict_num=5,how='holt_winters')
germany.predict_installation(predict_num=5,how='holt_winters')

print(f"Germany's total emission intensity yearly:\n {germany.calculate_co2_intensity()}")
print(f"PowerCo's emission intensity yearly:\n {powerco.calculate_co2_intensity()}")

df.info()